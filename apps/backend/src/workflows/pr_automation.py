"""PR Automation - Automated pull request creation workflow.

Handles:
- Creating feature branches
- Committing changes
- Running CI checks
- Creating PRs with comprehensive descriptions
- Requesting reviews (shadow mode)
- Storing PR metadata
"""

import subprocess
from datetime import datetime
from typing import Any

from pydantic import BaseModel, Field

from src.utils import get_logger

logger = get_logger(__name__)


class FileChange(BaseModel):
    """A file change to commit."""

    path: str
    description: str
    change_type: str = Field(description="added|modified|deleted")


class Branch(BaseModel):
    """Git branch information."""

    name: str
    base_branch: str = "main"
    created_at: str = Field(default_factory=lambda: datetime.now().isoformat())


class Commit(BaseModel):
    """Git commit information."""

    sha: str
    message: str
    author: str
    timestamp: str


class CIResult(BaseModel):
    """CI/CD check results."""

    passed: bool
    checks: dict[str, bool] = Field(default_factory=dict)
    output: str = ""


class PullRequest(BaseModel):
    """Pull request information."""

    number: int
    url: str
    title: str
    description: str
    branch: str
    base_branch: str
    created_at: str
    agent_metadata: dict[str, Any] = Field(default_factory=dict)


class PRAutomation:
    """Automated pull request creation workflow for shadow mode."""

    def __init__(self, repo_path: str = ".") -> None:
        """Initialize PR automation.

        Args:
            repo_path: Path to git repository
        """
        self.repo_path = repo_path

    async def create_feature_branch(
        self,
        feature_name: str,
        task_id: str,
        base_branch: str = "main"
    ) -> Branch:
        """Create a new feature branch for agent work.

        Args:
            feature_name: Name of feature being implemented
            task_id: Task/agent ID for uniqueness
            base_branch: Base branch to branch from

        Returns:
            Created branch info
        """
        # Generate branch name: feature/agent-{task-id}
        branch_name = f"feature/agent-{task_id}"

        logger.info(
            "Creating feature branch",
            branch=branch_name,
            base=base_branch
        )

        try:
            # Ensure we're on base branch
            subprocess.run(
                ["git", "checkout", base_branch],
                cwd=self.repo_path,
                check=True,
                capture_output=True
            )

            # Pull latest
            subprocess.run(
                ["git", "pull"],
                cwd=self.repo_path,
                check=True,
                capture_output=True
            )

            # Create and checkout new branch
            subprocess.run(
                ["git", "checkout", "-b", branch_name],
                cwd=self.repo_path,
                check=True,
                capture_output=True
            )

            branch = Branch(
                name=branch_name,
                base_branch=base_branch
            )

            logger.info(
                "Feature branch created",
                branch=branch_name
            )

            return branch

        except subprocess.CalledProcessError as e:
            logger.error(
                "Failed to create feature branch",
                branch=branch_name,
                error=e.stderr.decode() if e.stderr else str(e)
            )
            raise

    async def commit_changes(
        self,
        changes: list[FileChange],
        commit_message: str,
        agent_metadata: dict[str, Any]
    ) -> Commit:
        """Commit changes with descriptive message.

        Args:
            changes: List of file changes
            commit_message: Commit message
            agent_metadata: Agent metadata to include

        Returns:
            Commit information
        """
        logger.info(
            "Committing changes",
            file_count=len(changes),
            message=commit_message[:50]
        )

        try:
            # Stage changes
            for change in changes:
                subprocess.run(
                    ["git", "add", change.path],
                    cwd=self.repo_path,
                    check=True,
                    capture_output=True
                )

            # Create full commit message with agent attribution
            full_message = f"""{commit_message}

Generated by Agentic Layer v2.0

Agent Metadata:
- Agent ID: {agent_metadata.get('agent_id')}
- Task ID: {agent_metadata.get('task_id')}
- Verifier ID: {agent_metadata.get('verifier_id')}
- Attempts: {agent_metadata.get('attempts', 1)}

Co-Authored-By: Claude Agentic System <noreply@anthropic.com>
"""

            # Commit
            result = subprocess.run(
                ["git", "commit", "-m", full_message],
                cwd=self.repo_path,
                check=True,
                capture_output=True,
                text=True
            )

            # Get commit SHA
            sha_result = subprocess.run(
                ["git", "rev-parse", "HEAD"],
                cwd=self.repo_path,
                check=True,
                capture_output=True,
                text=True
            )

            commit = Commit(
                sha=sha_result.stdout.strip(),
                message=commit_message,
                author="Agentic Layer",
                timestamp=datetime.now().isoformat()
            )

            logger.info(
                "Changes committed",
                sha=commit.sha[:7],
                files=len(changes)
            )

            return commit

        except subprocess.CalledProcessError as e:
            logger.error(
                "Failed to commit changes",
                error=e.stderr if e.stderr else str(e)
            )
            raise

    async def run_ci_checks(
        self,
        branch_name: str
    ) -> CIResult:
        """Run CI checks on branch.

        Args:
            branch_name: Branch to check

        Returns:
            CI check results
        """
        logger.info(
            "Running CI checks",
            branch=branch_name
        )

        checks = {
            "type_check": False,
            "lint": False,
            "tests": False,
            "build": False
        }

        output_parts = []

        try:
            # Type check
            type_check = subprocess.run(
                ["pnpm", "turbo", "run", "type-check"],
                cwd=self.repo_path,
                capture_output=True,
                text=True
            )
            checks["type_check"] = type_check.returncode == 0
            output_parts.append(f"Type Check: {'âœ… Passed' if checks['type_check'] else 'âŒ Failed'}")

            # Lint
            lint = subprocess.run(
                ["pnpm", "turbo", "run", "lint"],
                cwd=self.repo_path,
                capture_output=True,
                text=True
            )
            checks["lint"] = lint.returncode == 0
            output_parts.append(f"Lint: {'âœ… Passed' if checks['lint'] else 'âŒ Failed'}")

            # Tests
            tests = subprocess.run(
                ["pnpm", "turbo", "run", "test"],
                cwd=self.repo_path,
                capture_output=True,
                text=True
            )
            checks["tests"] = tests.returncode == 0
            output_parts.append(f"Tests: {'âœ… Passed' if checks['tests'] else 'âŒ Failed'}")

            # Build (optional)
            build = subprocess.run(
                ["pnpm", "turbo", "run", "build"],
                cwd=self.repo_path,
                capture_output=True,
                text=True,
                timeout=600
            )
            checks["build"] = build.returncode == 0
            output_parts.append(f"Build: {'âœ… Passed' if checks['build'] else 'âŒ Failed'}")

        except Exception as e:
            logger.error(
                "CI checks failed with exception",
                error=str(e)
            )

        all_passed = all(checks.values())
        output = "\n".join(output_parts)

        result = CIResult(
            passed=all_passed,
            checks=checks,
            output=output
        )

        logger.info(
            "CI checks complete",
            passed=all_passed,
            checks=checks
        )

        return result

    async def create_pr(
        self,
        branch_name: str,
        title: str,
        description: str,
        agent_metadata: dict[str, Any],
        base_branch: str = "main"
    ) -> PullRequest:
        """Create pull request via GitHub CLI.

        Args:
            branch_name: Branch with changes
            title: PR title
            description: PR description
            agent_metadata: Agent metadata for PR
            base_branch: Target branch

        Returns:
            Created PR information
        """
        logger.info(
            "Creating pull request",
            branch=branch_name,
            title=title
        )

        # Generate comprehensive PR body
        pr_body = f"""{description}

---

### Agent Metadata

- **Agent ID**: `{agent_metadata.get('agent_id')}`
- **Task ID**: `{agent_metadata.get('task_id')}`
- **Verifier ID**: `{agent_metadata.get('verifier_id')}`
- **Attempts**: {agent_metadata.get('attempts', 1)}
- **Session ID**: `{agent_metadata.get('session_id', 'N/A')}`
- **Created**: {datetime.now().isoformat()}

### Verification Evidence

{agent_metadata.get('verification_evidence', 'No evidence provided')}

---

ðŸ¤– **Generated with Agentic Layer v2.0**

**Shadow Mode**: This PR requires human review before merging.
"""

        try:
            # Push branch
            subprocess.run(
                ["git", "push", "-u", "origin", branch_name],
                cwd=self.repo_path,
                check=True,
                capture_output=True
            )

            # Create PR using gh CLI
            result = subprocess.run(
                [
                    "gh",
                    "pr",
                    "create",
                    "--base",
                    base_branch,
                    "--head",
                    branch_name,
                    "--title",
                    title,
                    "--body",
                    pr_body
                ],
                cwd=self.repo_path,
                check=True,
                capture_output=True,
                text=True
            )

            # Parse PR URL from output
            pr_url = result.stdout.strip()

            # Extract PR number from URL
            pr_number = int(pr_url.split("/")[-1])

            pr = PullRequest(
                number=pr_number,
                url=pr_url,
                title=title,
                description=description,
                branch=branch_name,
                base_branch=base_branch,
                created_at=datetime.now().isoformat(),
                agent_metadata=agent_metadata
            )

            logger.info(
                "Pull request created",
                pr_number=pr_number,
                url=pr_url
            )

            return pr

        except subprocess.CalledProcessError as e:
            logger.error(
                "Failed to create PR",
                error=e.stderr if e.stderr else str(e)
            )
            raise

    async def request_review(
        self,
        pr_number: int,
        reviewers: list[str]
    ) -> bool:
        """Request review from specific reviewers.

        Args:
            pr_number: PR number
            reviewers: List of GitHub usernames

        Returns:
            True if review requested successfully
        """
        if not reviewers:
            logger.debug("No reviewers specified")
            return True

        logger.info(
            "Requesting PR review",
            pr=pr_number,
            reviewers=reviewers
        )

        try:
            subprocess.run(
                [
                    "gh",
                    "pr",
                    "edit",
                    str(pr_number),
                    "--add-reviewer",
                    ",".join(reviewers)
                ],
                cwd=self.repo_path,
                check=True,
                capture_output=True
            )

            logger.info(
                "Review requested",
                pr=pr_number,
                reviewers=reviewers
            )

            return True

        except subprocess.CalledProcessError as e:
            logger.error(
                "Failed to request review",
                pr=pr_number,
                error=e.stderr if e.stderr else str(e)
            )
            return False

    async def add_pr_comment(
        self,
        pr_number: int,
        comment: str
    ) -> bool:
        """Add comment to PR.

        Args:
            pr_number: PR number
            comment: Comment text

        Returns:
            True if comment added successfully
        """
        logger.info(
            "Adding PR comment",
            pr=pr_number
        )

        try:
            subprocess.run(
                ["gh", "pr", "comment", str(pr_number), "--body", comment],
                cwd=self.repo_path,
                check=True,
                capture_output=True
            )

            logger.info("Comment added to PR", pr=pr_number)
            return True

        except subprocess.CalledProcessError as e:
            logger.error(
                "Failed to add PR comment",
                pr=pr_number,
                error=e.stderr if e.stderr else str(e)
            )
            return False
